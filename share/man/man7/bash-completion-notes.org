#+TITLE:manpage-template

* NAME

bash-completion-notes - notes on BASH completion

* AUTOMATIC LOADING

When a user presses TAB to trigger completion for a command that does not have a
completion spec the function =_completion_loader= is called which will attempt
to find a file defining a completion for said command.

The function will look in a set of directories for a file defining a completion
spec for command, source said file and reattempt completion.

This way a package can provide completions without requiring users to source a
file in their dot files.

** For a package

For a package installed in =<prefix>=, completion files should be placed in
=<prefix>/share/bash-completion/completions= and have the same name as the
command they will define a completion for.

Loading the package should add =<prefix>/share= to the colon-separated list
=XDG_DATA_DIRS=.

If =bash-completion= version 2.12+ is used, then it is sufficient to add
=<prefix>/bin= to the =PATH=.

** Third party completions

If defining a completion for a command that is not yours, place completion files in
=$HOME/.local/share/bash-completion/completions= (see the first subsection of
Lookup Summary below).

Files must also have the same name as the command they define a completion for.

** Lookup summary

The function =_completion_loader= (deprecated in 2.12 in favor of =_comp_complete_load=)
constructs a list of directories to search in four ways.

*** User locations

Include =$d/bash-completion/completions= where =d= is the first of
- =$BASH_COMPLETION_USER_DIR=
- =$XDG_DATA_HOME=
- =$HOME/.local/share=
to have a non-empty value (the last one will always have a non-empty value).

*** Completions provided by =bash-completion= itself

The subdirectory =completions= of the base directory of =bash-completion=.

*** Directories obtained from PATH or the location of the command itself

In versions 2.12+ include =$d/share/bash-completion/completions= for each =d= in
- the dirname of the command if command contains a =/=,
- the realpath of the dirname of the command if command contains a =/=
- the directories of =$PATH=
- the directories of =$PATH= with =/bin= stripped from the end.

*** ~XDG_DATA_HOME~

Include =${d}/share/bash-completion/completions= for each =$d= in the colon
delimited list =$XDG_DATA_DIRS=.

** File Names
The file must be named either
1. Exactly the name of the command,
2. The name of the command followed by =.bash=,
3. The name of the command preceded by an underscore,
4. The name of the command preceded by an underscore and followed by =.bash= (only in 2.12+),
(no =*.sh=, and no replacing inner dashes with underscores).

If the same file defines completions for multiple commands, then create a
symbolic link for each of these commands pointing to that file.


* GIT

We can define lazy loaded completions for our git aliases and git commands.

** Files named =git-my-command=
When we request completions for =git my-command=, the completion function for
git will
- Attempt to call the shell function =_git_my_command= if it is defined,
- Call =_completion_loader git-my-command= which will look for a file named
  =[_]git-my-command[.bash= in the directories described above and should define
  the shell function =_git_my_command=.
- Reattempt to call the shell function =_git_my_command=.

Note that no completion specs need to be set for this, the file need only define
a shell function with the proper name that the completion spec for the command
=git= will call.

** Aliases
For git aliases, git will split the alias definition into words and use the
first word that is not one of the words to skip in =__git_aliased_command=.

The following aliases will both be completed the same way as =git ls-files=:
#+begin_src shell
[alias]
    x = ls-files
    y = "!f(){ : git ls-files ; git ... ; } ; f"
#+end_src

* CODE

** Directories

The following is the code of =_comp_load= in recent versions of [[https://github.com/scop/bash-completion][bash-completion]].

Earlier versions have the function =__load_completion= does mostly the same except that
- it does not have the #3 part
- treats =BASH_COMPLETION_USER_DIR= as a single directory rather than a colon-separated list.

#+begin_src shell
# Lookup order:
# 1) From BASH_COMPLETION_USER_DIR (e.g. ~/.local/share/bash-completion):
# User installed completions.
if [[ ${BASH_COMPLETION_USER_DIR-} ]]; then
    _comp_split -F : paths "$BASH_COMPLETION_USER_DIR" &&
        dirs+=("${paths[@]/%//completions}")
else
    dirs=("${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion/completions")
fi

# 2) From the location of bash_completion: Completions relative to the main
# script. This is primarily for run-in-place-from-git-clone setups, where
# we want to prefer in-tree completions over ones possibly coming with a
# system installed bash-completion. (Due to usual install layouts, this
# often hits the correct completions in system installations, too.)
dirs+=("$_comp__base_directory/completions")

# 3) From bin directories extracted from the specified path to the command,
# the real path to the command, and $PATH
paths=()
[[ $cmd == /* ]] && paths+=("${cmd%/*}")
_comp_realcommand "$cmd" && paths+=("${REPLY%/*}")
_comp_split -aF : paths "$PATH"
for dir in "${paths[@]%/}"; do
    [[ $dir == ?*/@(bin|sbin) ]] &&
        dirs+=("${dir%/*}/share/bash-completion/completions")
done

# 4) From XDG_DATA_DIRS or system dirs (e.g. /usr/share, /usr/local/share):
# Completions in the system data dirs.
_comp_split -F : paths "${XDG_DATA_DIRS:-/usr/local/share:/usr/share}" &&
    dirs+=("${paths[@]/%//bash-completion/completions}")
#+end_src

** Files

After =dirs= has been set, =_comp_load= has

#+begin_src shell
for prefix in "" _; do # Regular from all dirs first, then fallbacks
    for i in ${!dirs[*]}; do
        dir=${dirs[i]}
        for compfile in "$prefix$cmdname" "$prefix$cmdname.bash"; do
            compfile="$dir/$compfile"
            if [[ -e $compfile ]] && . "$compfile" "$cmd" "$@"; then
                return 0
            fi
        done
    done
done
#+end_src

which will source the first of these files =${cmdname}=, =${cmdname}.bash=,
=_${cmdname}=, =_${cmdname}.bash= to be found in one of the elements of =dirs=.

** Git
#+begin_src shell
__git_complete_command () {
	local command="$1"
	local completion_func="_git_${command//-/_}"
	if ! __git_have_func $completion_func &&
		__git_have_func _completion_loader
	then
		_completion_loader "git-$command"
	fi
	if __git_have_func $completion_func
	then
		$completion_func
		return 0
	elif __git_support_parseopt_helper "$command"
	then
		__git_complete_common "$command"
		return 0
	else
		return 1
	fi
}
#+end_src

* Adding completions to the =bash-completion= repo

This is not something we should do unless we want to actually submit a merge request.  Better to provide them with our package in =<prefix>/share/bash-completion/completions= and add =<prefix>= to =XDG_DATA_DIRS=.

But since I did spend the time to figure it out, might as well remember it here.

- Add =completions/_<CMD>= where =<CMD>= is the name of the command that should
  be completed.

- Run =generate <CMD>=.  This creates =test/t/test_<CMD>.py=.

- Add a test that has =@pytest.mark.complete("...", require_cmd=True)=.  This
  is because =update-test-cmd-list= greps for files that contain such a line.

- Run =update-test-cmd-list=.  This adds a line in =test/t/Makefile.am= and
  in =test/test-cmd-list.txt=.
